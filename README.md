# Connect Four AI Project

## Abstract
This document presents the final project for the artificial intelligence course, focusing on implementing a Connect Four game in Python. The project encompasses the creation of two different evaluation functions based on the course lectures. Additionally, it introduces various AI algorithms, including Minimax, Minimax with Alpha-beta pruning, A*, and Neural Networks. The project also covers bonus features such as an arbitrary m*n grid, a graphical user interface (GUI), and different game modes. The following table summarizes the project:

| MiniMax | Alpha-beta pruning | Two other search approaches | Arbitrary m*n | GUI | Player vs. Player | Player vs. AI | AI vs. AI |
|---------|---------------------|-----------------------------|--------------|-----|---------------------|---------------|-----------|
| ✓       | ✓                   | ✓                           | ✓            | ✓   | ✓                   | ✓             | ✓         |

## 1. Introduction
In the game of Connect Four, players take turns placing pieces in a vertical grid with the goal of connecting four pieces in a row, vertically, horizontally, or diagonally. The project explores adversarial search algorithms, considering the complete information nature of Connect Four. The game has been theoretically solved, with the first player having a winning strategy. The introduction provides an overview of the game and its complexity.

### 1.1 Search Algorithms
The section introduces search algorithms, including brute-force search and heuristics, which are essential for solving the constraint fulfillment problem. Local search methods, such as tree search algorithms, are discussed, covering exhaustive approaches like depth-first search and breadth-first search.

### 1.2 Adversarial Search
Adversarial search is explained as a scenario where an agent plans ahead while opponents plan against it. Connect Four is classified as an antagonistic, zero-sum game, considering only human intelligence and logic.

### 1.3 MiniMax Algorithm
The MiniMax algorithm is presented as a solution for adversarial search problems. The algorithm aims to maximize the agent's score while minimizing the opponent's score by assuming the opponent makes optimal moves.

### 1.4 Alpha-beta Pruning
Alpha-beta pruning is introduced as a technique to reduce the search space in the Minimax algorithm. By considering scores of sibling branches, the algorithm skips exploring branches that are not worth exploiting, significantly improving search efficiency.

## 2. The Game
This section explores different game modes and provides examples of the game environment.

### 2.1 Player vs. Player
Player vs. Player mode allows two human agents to play against each other through the terminal.

### 2.2 Player vs. AI
Player vs. AI mode enables a human player to face an AI opponent. The player can choose the AI's difficulty level and searching algorithm.

### 2.3 AI vs. AI
In this mode, two AI agents play against each other, each using a different algorithm and difficulty level.

## 3. The Alternative Search Algorithm
This section explores alternative search algorithms implemented for the project: A* and Neural Networks.

### 3.1 A* Algorithm
The A* algorithm, integrated with the adversarial search paradigm, efficiently explores the search space using Min-Queue and Max-Queue. The algorithm introduces depth constraints to limit exploration.

### 3.2 Neural Networks
A Neural Network model is developed to solve the adversarial search problem. The FC-NN model is trained on a dataset generated by playing against an Alpha-Beta agent. The training process and model structure are detailed.

## 4. The Code
This section introduces some uncharted parts of the implementation.

### 4.1 The Evaluation Function
Three different evaluation functions are implemented, influencing the searching algorithms. These functions focus on scoring based on the current position of the game, opportunities, and weighted scores.

#### 4.1.1 evaluate()
The function assigns scores based on the number of adjacent pieces of one color, aiming to prevent the opponent from making matches.

#### 4.1.2 evaluate_()
This function scores based on opportunities, considering whether the agent or the opponent can make four connected pieces on the board.

#### 4.1.3 evaluate__()
Similar to the previous function but with weighted scores, where the opponent's score has double the weight of the agent's score.

For further details and code implementation, refer to the source code files in the project repository.
